<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0083)http://rain.ifmo.ru/cat/view.php/theory/algorithm-analysis/dynamic-programming-2004 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

<title>Дискретная математика: алгоритмы. Динамическое программирование</title>
<link rel="stylesheet" href="./Дискретная математика  алгоритмы. Динамическое программирование_files/styles.css" type="text/css">
<link rel="alternate" type="application/atom+xml" title="Новости сайта CAT" href="http://rain.ifmo.ru/cat/atom.php">
<meta name="keywords" content="структура данных,алгоритм,программирование,визуализатор алгоритма,граф,сортировка,data structure,algorithm,programming,algorithm visualizer,graph,sorting">
</head>
<body>

<table id="head" cellspacing="0">
<tbody><tr>
<td id="logo"><a href="http://rain.ifmo.ru/cat/view.php/"><img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/cat.gif" width="130" height="130" alt="Computer Algorithm Tutor"></a></td>
<td>
<div id="title-line-1">
САНКТ-ПЕТЕРБУРГСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ<br>
ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ, МЕХАНИКИ И ОПТИКИ
</div>
<div id="title-line-2">
ФАКУЛЬТЕТ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ И ПРОГРАММИРОВАНИЯ<br>
КАФЕДРА КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ
</div>
<div id="title-line-3">
ДИСКРЕТНАЯ МАТЕМАТИКА: АЛГОРИТМЫ
</div>
</td>
<td align="right">
<!-- E-mail кодируется для предотвращения спама. Не пугайтесь. -->
<script type="text/javascript" src="./Дискретная математика  алгоритмы. Динамическое программирование_files/orphus.js"></script>
<a href="http://orphus.ru/" id="orphus" target="_blank" title="Orphus"><img alt="Orphus" src="./Дискретная математика  алгоритмы. Динамическое программирование_files/orphus.gif" border="0"></a>
</td>
</tr>
</tbody></table>

<div id="path">
<a href="http://rain.ifmo.ru/cat/view.php/">Первая страница</a> /
<a href="http://rain.ifmo.ru/cat/view.php/theory">Теория</a> /
<a href="http://rain.ifmo.ru/cat/view.php/theory/algorithm-analysis">Построение и анализ алгоритмов</a> /
<h1>Динамическое программирование</h1>
</div>

<table id="body" cellspacing="0">
<tbody><tr>
<td id="menu">
<a href="http://rain.ifmo.ru/cat/view.php/news">Новости</a>
<a href="http://rain.ifmo.ru/cat/view.php/theory" class="pressed">Теория</a>
<a href="http://rain.ifmo.ru/cat/view.php/vis">Визуализаторы</a>
<a href="http://rain.ifmo.ru/cat/view.php/books">Что почитать</a>
<a href="http://rain.ifmo.ru/cat/view.php/links">Ссылки</a>
<a href="http://rain.ifmo.ru/cat/view.php/aboutus">О нас</a>
<div class="separator">&nbsp;</div>
<a href="http://rain.ifmo.ru/cat/search.php">Поиск по сайту</a>
<div class="separator">&nbsp;</div>
<a href="http://rain.ifmo.ru/cat/view.php/contributors">Авторам</a>
<a href="http://rain.ifmo.ru/cat/view.php/feedback">Обратная связь</a>
<div class="separator">&nbsp;</div>
<a href="http://rain.ifmo.ru/cat/view.php/students">Студентам КТ</a>
<div class="separator">&nbsp;</div>

<!-- HotLog -->
<script type="text/javascript">
hotlog_r=""+Math.random()+"&amp;s=186237&amp;im=134&amp;r="+
escape(document.referrer)+"&amp;pg="+escape(window.location.href);
hotlog_r+="&amp;j="+(navigator.javaEnabled()?"Y":"N");
hotlog_r+="&amp;wh="+screen.width+"x"+screen.height+"&amp;px="+
(((navigator.appName.substring(0,3)=="Mic"))?screen.colorDepth:screen.pixelDepth);
hotlog_r+="&amp;js=1.3";
document.write('<a href="http://click.hotlog.ru/?186237" target="_blank"><img '+
'src="http://hit8.hotlog.ru/cgi-bin/hotlog/count?'+
hotlog_r+'" border="0" width="88" height="31" alt="HotLog"><\/a>');
</script><a href="http://click.hotlog.ru/?186237" target="_blank"><img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/count" border="0" width="88" height="31" alt="HotLog"></a>
<noscript>
&lt;a href="http://click.hotlog.ru/?186237" target="_blank"&gt;&lt;img
src="http://hit8.hotlog.ru/cgi-bin/hotlog/count?s=186237&amp;amp;im=134" border="0"
width="88" height="31" alt="HotLog"&gt;&lt;/a&gt;
</noscript>
<!-- /HotLog -->

<div class="separator">&nbsp;</div>

<!-- Concours "IT-education in Runet" banner -->
<a href="http://www.ict.edu.ru/konkurs/" target="_blank" class="plain">
<img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/laureat100x100.gif" width="100" height="100" alt="IT-образование в Рунете 2005"></a>
<!-- End of concours "IT-education in Runet" banner -->

<div class="separator">&nbsp;</div>
<a href="http://www.inforum.spb.ru/contest/champ-2004.asp" target="_blank" class="plain"><img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/nwforum.gif" width="100" height="75" alt="Победители конкурса сайтов Северо-Западного Интернет-форума 2004"></a>

</td>
<td id="content">

<form id="votes" action="http://rain.ifmo.ru/cat/vote.php/theory/algorithm-analysis/dynamic-programming-2004/" method="post">
Голосование:
<input type="image" name="vote" value="pro" src="./Дискретная математика  алгоритмы. Динамическое программирование_files/vote_pro.gif" alt="За "> 24,
<input type="image" name="vote" value="con" src="./Дискретная математика  алгоритмы. Динамическое программирование_files/vote_con.gif" alt="Против"> 1</form>

<h2>Введение</h2>

<p>
    <dfn>Динамическое программирование (ДП)</dfn> определяет оптимальное
    решение <var>n</var>-мерной задачи путем ее декомпозиции на <var>n</var>
    этапов, каждый из которых представляет собой подзадачу относительно одной
    переменной. Вычислительное преимущество такого подхода состоит в том, что
    мы занимаемся решением одномерных оптимизационных задач подзадач вместо
    большой <var>n</var>-мерной задачи.
</p>
<p>
    Фундаментальным принципом <em>ДП</em>, составляющим основу декомпозиции
    задачи на этапы, является <em>оптимальность</em>. Так как природа каждого
    этапа решения зависит от конкретной оптимизационной задачи, <em>ДП</em>
    не предлагает вычислительных алгоритмов непосредственно для каждого этапа.
    Вычислительные аспекты решения оптимизационных подзадач на каждом этапе
    проектируются и реализуются по отдельности (но это не исключает того, что
    может быть применен единый алгоритм для всех этапов).
</p>
<p>
    Вычисления в <em>ДП</em> выполняются рекуррентно в том смысле, что
    оптимальные решения одной подзадачи используются в качестве исходных
    данных для следующей подзадачи. Способ выполнения рекуррентных вычислений зависит
    от того, как выполняются декомпозиции исходной задачи. В данной ситуации
    возможны несколько вариантов. Первый из них это проводить вычисления
    последовательно от первого до последнего этапа, такая последовательность
    известна как <em>алгоритм прямой прогонки</em>. Задача может быть решена
    с помощью <em>алгоритма обратной прогонки</em>, в соответствии с которым
    вычисления проводятся от последнего этапа до первого. Очевидно, что
    алгоритмы прямой и обратной прогонки приводят к одному и тому же решению.
    Обычно более логичным представляется использовать алгоритм прямой
    прогонки, но в общем случае алгоритм обратной прогонки может быть более
    эффективным с вычислительной точки зрения. Продемонстрируем <em>ДП</em>
    на решение конкретных задач. Здесь будут рассмотрены следующие задачи:
</p>
<ul>
<li>задача о наибольшей общей подпоследовательности;</li>
<li>cвязь динамического программирования и регулярных выражений;</li>
<li>задача об оптимальной триангуляции;</li>
<li>задача о загрузке.</li>
</ul>


<h2>Задача о наибольшей общей подпоследовательности</h2>

<p>
    В различных биологических задачах часто необходимо сравнивать ДНК двух или
    нескольких организмов. Моделью молекулы ДНК можно считать строку, над
    алфавитом из четырех символов (А,&nbsp;Г,&nbsp;Ц,&nbsp;Т). Тогда поставить
    задачу можно следующим образом: даны две строки, требуется найти
    подпоследовательность наибольшей длины, входящую в оба слова. Теперь
    формализуем задачу в несколько более общем случае.
</p>
<p>
    Пусть у нас есть последовательность
    <var>X</var>&nbsp;=&nbsp;{<var>x</var><sub>1</sub>,&nbsp;<var>x</var><sub>2</sub>,&nbsp;…,&nbsp;<var>x</var><sub><var>m</var></sub>},
    тогда другая последовательность
    <var>Z</var>&nbsp;=&nbsp;{<var>z</var><sub>1</sub>,&nbsp;<var>z</var><sub>2</sub>,&nbsp;…,&nbsp;<var>z</var><sub><var>k</var></sub>}
    будет подпоследовательностью <var>X</var>, если существует такая
    возрастающая последовательность индексов
    <var>I</var>&nbsp;=&nbsp;{<var>i</var><sub>1</sub>,&nbsp;<var>i</var><sub>2</sub>,&nbsp;…,&nbsp;<var>i</var><sub><var>m</var></sub>},
    что для всех
    <var>j</var>&nbsp;=&nbsp;1,&nbsp;2,&nbsp;…,&nbsp;<var>k</var>, 
    будет верно равенство
    <var>x</var><sub><var>ij</var></sub>&nbsp;=&nbsp;<var>z<sub>j</sub></var>.
</p>
<p>
    <strong>Пример.</strong>
    <var>Z</var>&nbsp;=&nbsp;{B,&nbsp;C,&nbsp;D,&nbsp;B}&nbsp;—
    подпоследовательность
    <var>X</var>&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;C,&nbsp;B,&nbsp;D,&nbsp;A,&nbsp;B}
    с набором  индексов {2,&nbsp;3,&nbsp;5,&nbsp;7}.
</p>
<p>
    Говорят, что <var>Z</var>&nbsp;— общая подпоследовательность
    <var>X</var> и <var>Y</var>, если она является
    <em>подпоследовательностью</em> для <var>X</var> и <var>Y</var>. Тогда
    определим <dfn>наибольшую общую подпоследовательность (НОП)</dfn> двух
    данных последовательностей как общую подпоследовательность с максимальной
    длиной.
</p>
<p>
    Теперь задача окончательно формализована, и можно приступать к ее решению.
    Введем понятие <dfn><var>i-</var>го префикса</dfn> для заданной входной
    строки. Пусть имеется последовательность
    <var>X</var>&nbsp;=&nbsp;{<var>x</var><sub>1</sub>,&nbsp;<var>x</var><sub>2</sub>,&nbsp;…,<var>x</var><sub><var>m</var></sub>}.
    Определим ее <em><var>i</var>-ый префикс</em>
    (<var>i</var>&nbsp;=&nbsp;1,&nbsp;2,&nbsp;…,&nbsp;<var>m</var>) как
    <var>X<sub>i</sub></var>&nbsp;=&nbsp;{<var>x</var><sub>1</sub>,&nbsp;<var>x</var><sub>2</sub>,&nbsp;…,&nbsp;<var>x</var><sub><var>i</var></sub>},
    а <var>X<sub>0</sub></var> соответственно пустая последовательность. Для
    того, чтобы лучше понять структуру НОП, весьма полезна следующая теорема.
</p>

<h3>Теорема (о структуре НОП)</h3>
<p>
    Пусть
    <var>Z</var>&nbsp;=&nbsp;{<var>z</var><sub>1</sub>,&nbsp;<var>z</var><sub>2</sub>,&nbsp;…,&nbsp;<var>z</var><sub><var>k</var></sub>}&nbsp;—
    это любая НОП для последовательностей
    <var>X</var>&nbsp;=&nbsp;{<var>x</var><sub>1</sub>,&nbsp;<var>x</var><sub>2</sub>,&nbsp;…,&nbsp;<var>x</var><sub>n</sub>}
    и
    <var>Y</var>&nbsp;=&nbsp;{<var>y</var><sub>1</sub>,&nbsp;<var>y</var><sub>2</sub>,&nbsp;…,&nbsp;<var>y</var><sub><var>m</var></sub>}.
    Тогда
</p>
<ol>
<li> 
    Если <var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var>,
    то
    <var>z<sub>k</sub></var>&nbsp;=&nbsp;<var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var>
    и <var>Z</var><sub><var>k</var>&#8722;1</sub>&nbsp;—
    это НОП <var>X</var><sub><var>n</var>&#8722;1</sub> и <var>Y</var><sub><var>m</var>&#8722;1</sub>.
</li>
<li> 
    Если <var>x<sub>n</sub></var>&nbsp;&#8800;&nbsp;<var>y<sub>m</sub></var>
    и <var>z<sub>k</sub></var>&nbsp;&#8800;&nbsp;<var>x<sub>n</sub></var>,
    то <var>Z</var>&nbsp;— это НОП
    <var>X</var><sub><var>n</var>&#8722;1</sub> и <var>Y</var>.
</li>
<li> 
    Если <var>x<sub>n</sub></var>&nbsp;&#8800;&nbsp;<var>y<sub>m</sub></var>
    и <var>z<sub>k</sub></var>&nbsp;&#8800;&nbsp;<var>y<sub>m</sub></var>,
    то <var>Z</var>&nbsp;— это НОП <var>X</var>
    и <var>Y</var><sub><var>m</var>&#8722;1</sub>.
</li>
</ol>
<p><strong>Доказательство.</strong></p>
<ol>
<li> 
    Предположим, что
    <var>z<sub>n</sub></var>&nbsp;&#8800;&nbsp;<var>x<sub>n</sub></var>.
    Тогда мы можем присоединить
    <var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var>
    к <var>Z</var> и получить общую последовательность для <var>X</var>
    и <var>Y</var> длины <var>k</var>+1, но это противоречит нашему
    предположению о том, что <var>Z</var>&nbsp;— это НОП <var>X</var>
    и <var>Y</var>. Таким образом,
    <var>z<sub>k</sub></var>&nbsp;=&nbsp;<var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var>.
    Теперь, префикс <var>Z</var><sub><var>k</var>&#8722;1</sub>&nbsp;—
    это общая подпоследовательность для
    <var>X</var><sub><var>n</var>&#8722;1</sub>
    и <var>Y</var><sub><var>n</var>&#8722;1</sub> длины <var>k</var>&#8722;1.
    Покажем, что она является НОП для
    <var>X</var><sub><var>n</var>&#8722;1</sub>
    и <var>Y</var><sub><var>n</var>&#8722;1</sub>. Предположим, что это не
    так, тогда существует общая подпоследовательность <var>W</var>
    для<var>X</var><sub><var>n</var>&#8722;1</sub>
    и <var>Y</var><sub><var>n</var>&#8722;1</sub> длины большей, чем
    <var>k</var>&#8722;1. Тогда присоединяя к <var>W</var>
    <var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var> получим
    подпоследовательность общую для <var>X</var> и <var>Y</var>, длины большей, 
    чем <var>k</var>, что противоречит условию.
</li>
<li> 
    Нужно показать, что если
    <var>z<sub>n</sub></var>&nbsp;&#8800;&nbsp;<var>x<sub>n</sub></var>,
    то <var>Z</var>&nbsp;— это НОП
    <var>X</var><sub><var>n</var>&#8722;1</sub> и <var>Y</var>. Предположим,
    что это не так, тогда существует подпоследовательность <var>W</var> общая
    подпоследовательность для <var>X</var><sub><var>n</var>&#8722;1</sub>
    и <var>Y</var> длины большей <var>k</var>. Но тогда <var>W</var> также
    общая подпоследовательность для <var>X<sub>n</sub></var> и <var>Y</var>,
    что противоречит тому, что <var>Z</var> это НОП для <var>X</var>
    и <var>Y</var>.
</li>
<li> 
    Доказательство этого пункта совершенно аналогично предыдущему.
</li>
</ol>

<p>
    Непосредственно из теоремы следует способ нахождения НОП двух заданных
    последовательностей
    <var>X</var>&nbsp;=&nbsp;{<var>x</var><sub>1</sub>,&nbsp;<var>x</var><sub>2</sub>,&nbsp;…,&nbsp;<var>x</var><sub><var>n</var></sub>}
    и
    <var>Y</var>&nbsp;=&nbsp;{<var>y</var><sub>1</sub>,&nbsp;<var>y</var><sub>2</sub>,&nbsp;…,&nbsp;<var>y</var><sub><var>m</var></sub>}.
    Если <var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var>, то мы
    должны искать НОП для <var>X</var><sub><var>n</var>&#8722;1</sub>
    и <var>Y</var><sub><var>m</var>&#8722;1</sub> и, присоединив к этому
    результату <var>x<sub>n</sub></var>&nbsp;=&nbsp;<var>y<sub>m</sub></var>,
    мы получим НОП для <var>X</var> и <var>Y</var>. Если
    же <var>x<sub>n</sub></var>&nbsp;&#8800;&nbsp;<var>y<sub>m</sub></var>, то мы
    должны решить две подзадачи: первая НОП
    <var>X</var><sub><var>n</var>&#8722;1</sub> и <var>Y</var>, вторая найти
    НОП <var>X</var> и <var>Y</var><sub><var>m</var>&#8722;1</sub>. Затем
    выбрать наибольший из двух результатов, это и будет НОП <var>X</var>и
    <var>Y</var>. Заметим, что каждая из двух подзадач потребует решения вновь
    появившихся подзадач, которые в свою очередь будут выявлять все новые
    подзадачи.
</p>
<p>
    Остается только выбрать какой из двух алгоритмов прогонки здесь больше
    подходит, <em>прямой</em> или <em>обратной</em>. С вычислительной точки
    зрения наиболее рациональным будет алгоритм прямой прогонки, вычисляющий
    НОП снизу вверх. В случае вычисления очень удобно организовать в виде
    таблицы <var>c</var>[0…<var>n</var>,&nbsp;0…<var>m</var>],
    где <var>c</var>[<var>i</var>][<var>j</var>] соответствует длине НОП
    префиксов <var>X<sub>i</sub></var> и <var>Y<sub>j</sub></var>. Значение
    <var>c</var>[<var>i</var>][<var>j</var>] можем вычислять по следующим
    правилам:
</p>
<ul>
<li>
    0, если <var>i</var>&nbsp;=&nbsp;0 или <var>j</var>&nbsp;=&nbsp;0;
</li>
<li>
    <var>c</var>[<var>i</var>&#8722;1][<var>j</var>&#8722;1]&nbsp;+&nbsp;1, если 
    <var>i</var>,&nbsp;<var>j</var>&nbsp;&gt;&nbsp;0 и
    <var>x<sub>i</sub></var>&nbsp;=&nbsp;<var>y<sub>j</sub></var>;
</li>
<li>
    max(<var>c</var>[<var>i</var>][<var>j</var>&#8722;1],&nbsp;<var>c</var>[<var>i</var>&#8722;1][<var>j</var>]),
    если <var>i</var>,&nbsp;<var>j</var>&nbsp;&gt;&nbsp;0
    и <var>x<sub>i</sub></var>&nbsp;&#8800;&nbsp;<var>y<sub>j</sub></var>.
</li>
</ul>
<p>
    Таким образом, мы можем найти длину НОП, а для того чтобы найти саму НОП,
    необходимо хранить некоторую дополнительную информацию. Удобно хранить
    информацию, о том, по какому условию осуществляется переход. На примере
    это можно проиллюстрировать с помощью стрелочек, тогда, возвращаясь назад
    по стрелочкам, мы найдем все символы, которые входят в НОП. На псевдокоде
    это будет выглядеть так
</p>

<!-- код текстом -->
<pre><code>
LCS-LENGTH(X,Y)
 1 m = length[X]
 2 m = length[Y]
 3 for i = 1 to m
 4   do c[i, 0] = 0
 5 for i = 1 to m
 6   do c[0, j] = 0
 7 for i = 1 to m do
 8   do for j = 1 to n
 9     do if <var>x<sub>i</sub></var> = <var>y<sub>i</sub></var>
10            then c[i,j] = c[i &#8722; 1, j &#8722; 1] + 1;
11                 b[i,j] = «стрелка по диагонали»
12            else if c[i &#8722; 1, j] &#8805; c[i, j - 1]
13                    then c[i, j] = c[i &#8722; 1, j]
14                         b[i, j] = «стрелка вверх»
15                    else c[i, j] = c[i, j &#8722; 1]
16                         b[i, j] = «стрелка влево»
17 return b, c
</code></pre>

<p>
    На следующем рисунке показана работа алгоритма для
    <var>X</var>&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;C,&nbsp;B,&nbsp;D,&nbsp;A,&nbsp;B}
    и <var>Y</var>&nbsp;=&nbsp;{B,&nbsp;D,&nbsp;C,&nbsp;A,&nbsp;B,&nbsp;A}
</p>

<img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/result.gif" alt="Результат работы алгоритма на примере"> 

<p>Теперь покажем, как непосредственно найти саму НОП.</p>
<pre><code>
PRINT_LCS(b, X, i, j)
1 if i = 0 or j = 0
2    then return
3 if b[i, j] = «стрелка по диагонали»
4    then PRINT_LCS(b, X, i &#8722; 1, j &#8722; 1)
5         print <var>v<sub>i</sub></var>
6 elseif b[im j] = «стрелка вверх»
7    then PRINT_LCS(b, X, i &#8722; 1, j)
8 else PRINT_LCS (b, X, i, j &#8722; 1)
</code></pre>
<p>
    Может показаться, что эта задача была разобрана слишком подробно, но это
    сделано лишь для того, чтобы прояснить все детали происходящего,
    в следующих примерах некоторые мелкие детали могут быть опущены. Более
    интересный пример для развития приведенных выше идей, представляет собой
    следующая задача.
</p>


<h2>Связь динамического программирования и регулярных выражений</h2>

<p>
    Шаблоном называется строка состоящая из букв латинского алфавита
    (a,&nbsp;…,&nbsp;z,&nbsp;A,&nbsp;…,&nbsp;Z) и символов ?
    и *. Каждый из символов ? разрешается заменить на одну произвольную букву,
    а каждый из символов * на произвольную (возможно пустую) последовательность
    букв. Про любую строку из букв, которую можно получить из шаблонов такими
    заменами, будем говорить, что она удовлетворяет данному шаблону. Тогда
    задачу состоит в том, чтобы для двух заданных шаблонов найти строку
    минимальной длины, которая удовлетворяет обоим шаблонам, либо выяснить,
    что такой строки не существует.
</p>
<p>
    Нельзя не отметить, что подобного рода задачи, находят большое применение
    на практике, обычно они возникают при анализе и разборе регулярных
    выражений. Итак, пусть заданы два шаблона,
    <var>S</var>[1…<var>M</var>] и <var>T</var>[1…<var>N</var>].
    Введем обозначение <var>F</var>(<var>i</var>,&nbsp;<var>j</var>) для
    строки минимальной длины, которая удовлетворяет шаблонам
    <var>S</var>[1…<var>i</var>] и <var>T</var>[1…<var>j</var>].
    Если такой строки нет, то в <var>F</var>(<var>i</var>,&nbsp;<var>j</var>),
    будет стоять специальная пометка, говорящая об этом.
</p>
<p>
    Вычисляем значение <var>F</var>(<var>i</var>,&nbsp;<var>j</var>) в порядке
    возрастания <var>i</var>, а при равных <var>i</var>, в порядке возрастания
    <var>j</var>. Возможны следующие содержательные ситуации (считаем, что
    <var>i</var>,&nbsp;<var>j</var>&nbsp;&gt;&nbsp;0, а разбор граничных
    случаев, не представляет особого интереса, и может быть оставлен как
    упражнение).
</p>
<ol>
<li>
    <var>S</var>[<var>i</var>] и <var>T</var>[j]&nbsp;— буквы. Если они
    совпадают, то в качестве значения
    <var>F</var>(<var>i</var>,&nbsp;<var>j</var>) берем
    <var>F</var>(<var>i</var>&#8722;1,&nbsp;<var>j</var>&#8722;1)
    с добавленной в конце этой буквой. Если
    в <var>F</var>(<var>i</var>&#8722;1,&nbsp;<var>j</var>&#8722;1) стоит
    пометка, говорящая о том, что строки не существует, то аналогичную пометку
    можно поставить и в <var>F</var>(<var>i</var>,&nbsp;<var>j</var>).
    В случае несовпадения букв <var>S</var>[<var>i</var>]
    и <var>T</var>[<var>j</var>],
    в <var>F</var>(<var>i</var>,&nbsp;<var>j</var>) необходимая строка также
    не существует.
</li>
<li>
    <var>S</var>[<var>i</var>] и <var>T</var>[<var>j</var>]&nbsp;— буква
    и символ «?» или два символа «?». Поступаем точно
    так же, как и в предыдущей ситуации, однако случае несовпадения букв из-за
    наличия «?» здесь быть не может.
</li>
<li>
    <var>S</var>[<var>i</var>]&nbsp;— символ «*»,
    а <var>T</var>[<var>j</var>]&nbsp;— буква или символ
    «?». В данной ситуации выбираем наиболее короткое среди
    значений <var>F</var>(<var>i</var>,&nbsp;<var>j</var>&#8722;1)
    и <var>F</var>(<var>i</var>&#8722;1,&nbsp;<var>j</var>) с дописанной
    к нему буквой <var>T</var>[<var>j</var>] (или любой буквой, если
    <var>T</var>[<var>j</var>] есть символ «?» ).
</li>
<li>
     <var>S</var>[<var>i</var>]&nbsp;— буква или символ «?»,
     а <var>T</var>[<var>j</var>]&nbsp;— символ «*».
     Поступаем аналогично разобранному выше пункту.
</li>
<li>
    <var>S</var>[<var>i</var>] и <var>T</var>[<var>j</var>]&nbsp;— два
    символа «*». В этом случае в качестве
    <var>F</var>(<var>i</var>,&nbsp;<var>j</var>), берем наиболее короткое
    из значений <var>F</var>(<var>i</var>,&nbsp;<var>j</var>&#8722;1)
    и <var>F</var>(<var>i</var>&#8722;1,&nbsp;<var>j</var>).
</li>
</ol>


<h2>Задача триангуляции</h2>

<p>
    В качестве еще одного примера динамического программирования рассмотрим
    <dfn>задачу триангуляции многоугольника</dfn>. Заданы вершины
    многоугольника и расстояния между каждой парой вершин. Это расстояние
    может быть геометрическим расстоянием на плоскости или произвольной
    функцией стоимости, заданной в виде таблицы. Задача заключается в том,
    чтобы выбрать такую совокупность <dfn>хорд</dfn> (линий между несмежными
    вершинами), что никакие две хорды не будут пересекаться, а весь
    многоугольник будет поделен на треугольники. Общая длин всех хорд должна
    быть минимальной. Такая совокупность хорд называется минимальной
    триангуляцией. Зафиксируем несколько фактов, которые помогут разработать
    необходимый алгоритм. Предполагаем, что наш многоугольник имеет
    <var>n</var> вершин
    <var>v</var><sub>0</sub>,&nbsp;<var>v</var><sub>1</sub>,&nbsp;…,&nbsp;<var>v</var><sub><var>n</var>&#8722;1</sub>,
    перечисленных по часовой стрелке.
</p>
<ol>
<li> 
    В случае триангуляции любого многоугольника, содержащего более 
    трех вершин, с каждой парой смежных вершин связана, по крайней 
    мере одна хорда. Чтобы убедиться в этом, предположим, что ни 
    <var>v<sub>i</sub></var>, ни <var>v</var><sub><var>i</var>+1</sub>
    не связаны ни с одной из хорд. В таком случае область, ограничиваемая
    стороной
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+1</sub>),
    должна бы включать стороны
    (<var>v</var><sub><var>i</var>&#8722;1</sub>,&nbsp;<var>v<sub>i</sub></var>),
    (<var>v</var><sub><var>i</var>+1</sub>,&nbsp;<var>v</var><sub><var>i</var>+2</sub>)
    и по крайней мере еще одну дополнительную сторону или хорду. Но в таком
    случае это область не была бы треугольником.
</li>
<li>
    Если (<var>v<sub>i</sub></var>,&nbsp;<var>v<sub>j</sub></var>) является
    хордой в триангуляции, значит должна найтись, такая вершина
    <var>v<sub>k</sub></var> что каждая из линий
    (<var>v<sub>i</sub></var>,&nbsp;<var>v<sub>k</sub></var>)
    и (<var>v<sub>k</sub></var>,&nbsp;<var>v<sub>i</sub></var>) либо стороной
    многоугольника либо хордой . В противном случае хорда
    (<var>v<sub>i</sub></var>,&nbsp;<var>v<sub>j</sub></var>), ограничивала
    бы область, не являющуюся треугольником.
</li>
</ol>
<p>
    Чтобы приступить к поиску минимальной триангуляции, выберем две смежные
    вершины, например <var>v</var><sub>0</sub> и <var>v</var><sub>1</sub>.
    Из указанных выше фактов следует, что в любой триангуляции (а значит и
    в минимальной) должна найтись такая вершина <var>v<sub>k</sub></var>, что
    (<var>v</var><sub>1</sub>,&nbsp;<var>v<sub>k</sub></var>)
    и (<var>v<sub>k</sub></var>,&nbsp;<var>v</var><sub>0</sub>) являются
    хордами или сторонами многоугольника. Необходимо рассмотреть, насколько
    приемлемую триангуляцию можно построить после выбора каждого значения
    <var>k</var>. Если в многоугольнике <var>n</var> вершин, то в нашем
    распоряжении имеется (<var>n</var>&#8722;2) возможных вариантов. Каждый
    вариант выбора <var>k</var> приводит к не более чем двум подзадачам, где
    мы имеем многоугольники образованные, одной хордой и сторонами исходного
    многоугольника. Например, могут возникнуть такие подзадачи при случае
    выбора вершины <var>v</var><sub>3</sub>.
</p>
<img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/triang.gif" alt="Рис. 1. Две подзадачи, возникающие после выбора вершины v3"> 
<p>
    Далее нужно найти минимальную триангуляцию для многоугольников, полученных
    в результате появления новых подзадач. Правда, если мы будем решать все
    подзадачи, которые будут появляться, то мы получим алгоритм
    с экспоненциальной трудоемкостью. Но, имея треугольник, включающий хорду
    (<var>v</var><sub>0</sub>, <var>v<sub>k</sub></var>), нам никогда
    не придется рассматривать многоугольники, у которых более одной стороны
    являются хордами исходного многоугольника. «Факт&nbsp;2»
    говорит о том, что при минимальной триангуляции хорда в подзадаче
    (например, хорда (<var>v</var><sub>0</sub>,&nbsp;<var>v</var><sub>3</sub>)
    на рис.&nbsp;1) должна составлять треугольник с одной из остальных вершин
    многоугольника.
</p>
<p>
    Определим подзадачу размера <var>s</var>, начинающуюся с вершины
    <var>v<sub>i</sub></var> и обозначаемую <var>S<sub>is</sub></var>, как
    задачу минимальной триангуляции для многоугольника, образованного
    <var>s</var> вершинами, начинающегося с вершины <var>v<sub>i</sub></var>
    и содержащего вершины
    <var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+1</sub>,&nbsp;…,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>,
    перечисляемые в порядке обхода вершин по часовой стрелке.
    В <var>v</var><sub>0</sub> хордой является замыкающая сторона
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>).
    Чтобы решить подзадачу <var>S<sub>is</sub></var> необходимо рассмотреть
    три варианта:
</p>
<ol>
<li> 
    Можно выбрать вершину
    <var>v</var><sub><var>i</var>+<var>s</var>&#8722;2</sub>,
    чтобы составить треугольник с хордами
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>),
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;2</sub>)
    и третьей стороной
    (<var>v</var><sub><var>i</var>+<var>s</var>&#8722;2</sub>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>),
    а затем решить подзадачу
    <var>S</var><sub><var>i</var>,<var>s</var>&#8722;1</sub>.
</li>
<li> 
    Мы можем выбрать вершину <var>v</var><sub><var>i</var>+1</sub>, чтобы
    составить треугольник с хордами
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>),
    (<var>v</var><sub><var>i</var>+1</sub>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>)
    и третьей стороной
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+1</sub>),
    а затем решить подзадачу <var>S</var><sub><var>i</var>+1,<var>s</var>&#8722;1</sub>.
</li>
<li> 
    Для некоторого <var>k</var> из диапазона от 2 до <var>s</var>&#8722;3
    можно выбрать вершину <var>v</var><sub><var>i</var>+<var>k</var></sub>
    и образовать треугольник со сторонами
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>k</var></sub>),
    (<var>v</var><sub><var>i</var>+<var>k</var></sub>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>),
    (<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>),
    а затем решить подзадачи
    <var>S</var><sub><var>i</var>,<var>k</var>+1</sub> и
    <var>S</var><sub><var>i</var>+<var>k</var>,<var>s</var>&#8722;<var>k</var></sub>.
</li>
</ol>
<p>
    Если учесть, что решение подзадачи размером не более трех не требует
    вообще никаких действий, то рассматривая описанные варианты 1–3, следует
    предпочесть вариант 3, где нужно выбрать некоторое <var>k</var>
    из диапазона от 1 до <var>s</var>&#8722;2 и решить подзадачи
    <var>S</var><sub><var>i</var>,<var>k</var>+1</sub>
    <var>S</var><sub><var>i</var>+<var>k</var>,<var>s</var>&#8722;<var>k</var></sub>.
    Если для решения задачи размером более четыре и более воспользоваться
    очевидным рекурсивным алгоритмом, непосредственно вытекающим
    из перечисленных выше вариантов, то можно показать что общее число
    рекурсивных вызовов составляет 3<sup><var>s</var>&#8722;4</sup>, если
    подсчитать лишь обращения к подзадачам размером четыре и более. Таким
    образом количество подзадач, которые необходимо решить, возрастает
    по экспоненциальному закону в зависимости от <var>s</var>. А следовательно
    общее количество шагов экспоненциально зависит и от <var>n</var>.
</p>
<img src="./Дискретная математика  алгоритмы. Динамическое программирование_files/tasks_ik.gif" alt="Рис. 2. Разбиение задачи Sis на подзадачи"> 
<p>
    Но известно, что, помимо исходной задачи существует лишь
    <var>n</var>(<var>n</var>&#8722;4) различных подзадач, которые в любом
    случае необходимо решить. Значит в приведенном анализе что-то явно
    не совсем верно. Очевидно, что совсем не все подзадачи отличаются между
    собой, если действовать рекурсивно, как приведено выше, то у нас возникают
    ситуации, когда одни и те же ситуации приходится решать несколько раз.
    Именно это подсказывает нам эффективный способ вычисления триангуляции.
    Прежде всего, вычисления удобно организовать в виде таблицы. Назначим
    стоимость <var>C<sub>is</sub></var> триангуляции <var>S<sub>is</sub></var>
    для всех <var>i</var> и <var>s</var>. Поскольку решение любой данной 
    задачи зависит от решения задач меньшего размера, то логичным порядком 
    заполнения такой таблицы является порядок, основанный на размерах 
    подзадач, т.&nbsp;е. для размеров
    <var>s</var>&nbsp;=&nbsp;4,&nbsp;5,&nbsp;…,&nbsp;<var>n</var>&#8722;1
    мы указываем минимальную стоимость задач <var>S<sub>is</sub></var> для
    всех вершин <var>i</var>. Удобно включить и задачи размеров
    0&nbsp;&#8804;&nbsp;<var>s</var>&nbsp;&lt;&nbsp;4, но при этом нужно помнить,
    что <var>S<sub>is</sub></var> имеет стоимость 0, если
    <var>s</var>&nbsp;&lt;&nbsp;4.
</p>
<p>
    В соответствии с перечисленными выше вариантами действий 1–3 при
    определении подзадач формула вычисления <var>C<sub>is</sub></var> при
    <var>s</var>&nbsp;&#8805;&nbsp;4 должна иметь следующий вид:
</p>
<div class="formula">
    <var>C<sub>is</sub></var>&nbsp;=
    min<sub>1&#8804;<var>k</var>&#8804;<var>s</var>&#8722;2</sub> 
    {<var>C</var><sub><var>i</var>,<var>k</var>+1</sub>&nbsp;+
    <var>C</var><sub><var>i</var>+<var>k</var>,<var>s</var>&#8722;<var>k</var></sub>&nbsp;+
    <var>D</var>(<var>v<sub>i</sub></var>,&nbsp;<var>v</var><sub><var>i</var>+<var>k</var></sub>)&nbsp;+
    <var>D</var>(<var>v</var><sub><var>i</var>+<var>k</var></sub>,&nbsp;<var>v</var><sub><var>i</var>+<var>s</var>&#8722;1</sub>)},
</div>
<p>
    где
    <var>D</var>(<var>v<sub>p</sub></var>,&nbsp;<var>v<sub>q</sub></var>)&nbsp;—
    это длина хорды между вершинами <var>v<sub>p</sub></var>
    и <var>v<sub>q</sub></var>, если <var>v<sub>p</sub></var>
    и <var>v<sub>q</sub></var> не являются смежными вершинами многоугольника;
    <var>D</var>(<var>v<sub>p</sub></var>,&nbsp;<var>v<sub>q</sub></var>)
    равняется 0, если являются смежными вершинами.
</p>
<p>
    Отметим, что таким образом, мы вычислим всю таблицу, и определим стоимость
    минимальной триангуляции, но не саму триангуляцию. Поэтому, как и в задаче
    про <em>наибольшую общую подпоследовательность</em> для того, чтобы найти
    саму триангуляцию, мы должны еще также хранить информацию, о том, при
    каком значении <var>k</var> достигается минимум. И потом уже, по всем
    сохраненным значениям <var>k</var> мы можем легко восстановить
    минимальную триангуляцию.
</p>


<h2>Задача о загрузке</h2>

<p>
    Задача о загрузке&nbsp;— это задача о рациональной загрузке судна
    (самолета, автомашины, и т.&nbsp;п.), которое имеет ограничения по объему
    или грузоподъемности. Каждый помещенный на судно груз приносит
    определенную прибыль. Задача состоит в том, чтобы определении загрузки,
    такими грузами которые приносят наибольшую прибыль.
</p>
<p>
    Отметим также, что данная задача известна как <em>задача о рюкзаке</em>,
    в который турист должен определить наиболее ценные предметы, подлежащие
    загрузке в рюкзак. Формализуем нашу задачу. Пусть
    <var>W</var>&nbsp;— грузоподъемность нашего судна и есть в наличии
    <var>n</var> наименований предметов, которые подлежат загрузке. Пусть
    <var>m<sub>i</sub></var>&nbsp;— количество предметов <var>i</var>-го
    наименования, <var>r<sub>i</sub></var>&nbsp;— прибыль, которую
    приносит один загруженный предмет <var>i</var>-го наименования,
    <var>w<sub>i</sub></var>&nbsp;— вес одного предмета <var>i</var>-го
    наименования. Тогда общая задача имеет вид следующей целочисленной задачи
    линейного программирования.
</p>
<p>
    Максимизировать <var>Z</var>&nbsp;=
    <var>r</var><sub>1</sub><var>m</var><sub>1</sub>&nbsp;+
    <var>r</var><sub>2</sub><var>m</var><sub>2</sub>&nbsp;+&nbsp;…&nbsp;+
    <var>r<sub>n</sub></var><var>m<sub>n</sub></var> при условии, что
</p>
<div class="formula">
    <var>w</var><sub>1</sub><var>m</var><sub>1</sub>&nbsp;+
    <var>w</var><sub>2</sub><var>m</var><sub>2</sub>&nbsp;+&nbsp;…&nbsp;+
    <var>w<sub>n</sub></var><var>m<sub>n</sub></var>&nbsp;&#8804;&nbsp;<var>W</var>,<br>
    <var>m</var><sub>1</sub>,&nbsp;<var>m</var><sub>2</sub>,&nbsp;…,&nbsp;<var>m<sub>n</sub></var>&nbsp;&#8805;&nbsp;0.
</div>
<p>
    Рассмотрим подход, несколько иной, чем был приведен выше. При рассмотрении
    каждой конкретной задачи обратим внимание три основных элемента модели
    <em>динамического программирования.</em>.
</p>
<ol>
<li>Определение этапов.</li>
<li>Определения на каждом этапе вариантов решения (альтернатив).</li>
<li>Определения состояний на каждом этапе.</li>
</ol>
<p>
    Из перечисленных выше элементов понятие <em>состояние</em>, как правило,
    представляется весьма сложным для восприятия. Определение этого понятия
    может меняться в зависимости от конкретной ситуации. При рассмотрении
    каждого приложения полезно ответить на следующие вопросы.
</p>
<ol>
<li>Какие соотношения связывают этапы вместе?</li>
<li>
    Какая информация необходима для того, чтобы получить допустимые решения
    на текущем этапе без повторной проверки решений, принятых на предыдущих
    этапах.
</li>
</ol>
<p>
    В приведенной задаче о загрузке три элемента модели <em>динамического
    программирования</em> определяются следующим образом.
</p>
<ol>
<li>
    Этап <var>i</var> ставится в соответствие предмету <var>i</var>-го
    наименования,
    <var>i</var>&nbsp;=&nbsp;1,&nbsp;2,&nbsp;…,&nbsp;<var>n</var>.
</li>
<li>
    Варианты решения на этапе <var>i</var> описываются количеством предметов
    <var>m<sub>i</sub></var> предметов <var>i</var>-го наименования,
    подлежащих загрузке. Соответствующая прибыль равна
    <var>r<sub>i</sub></var><var>m<sub>i</sub></var>. Значение заключено
    <var>m<sub>i</sub></var> в пределах от 0 до
    [<var>W</var>&#8260;<var>w<sub>i</sub></var>], где
    [<var>W</var>&#8260;<var>w<sub>i</sub></var>]&nbsp;— целая часть
    числа <var>W</var>&#8260;<var>w<sub>i</sub></var>.
</li>
<li>
    Состояние <var>x<sub>i</sub></var> на <var>i</var> выражает суммарный вес
    предметов, решения о погрузке которых приняты на этапах
    <var>i</var>,&nbsp;<var>i</var>+1,&nbsp;…,&nbsp;<var>n</var>. Это
    определение отражает тот факт, что ограничение по весу является
    единственным, которое связывает вместе все <var>n</var> этапов.
</li>
</ol>
<p>
    Пусть <var>f<sub>i</sub></var>(<var>x<sub>i</sub></var>)&nbsp;—
    максимальная суммарная прибыль от этапов
    <var>i</var>,&nbsp;<var>i</var>+1,&nbsp;…,&nbsp;<var>n</var> при
    заданном состоянии <var>x<sub>i</sub></var>. Определим рекуррентное
    уравнение с помощью следующей двухшаговой процедуры.
</p>
<ol>
<li>
    Выразим <var>f<sub>i</sub></var>(<var>x<sub>i</sub></var>) как функцию
    <var>f</var><sub><var>i</var>+1</sub>(<var>x</var><sub><var>i</var>+1</sub>)
    в виде
    <div class="formula">
        <var>f<sub>i</sub></var>(<var>x<sub>i</sub></var>)&nbsp;=
        max&nbsp;{<var>r<sub>i</sub></var><var>m<sub>i</sub></var>&nbsp;+
        <var>f</var><sub><var>i</var>+1</sub>(<var>x</var><sub><var>i</var>+1</sub>)},
        <var>i</var>&nbsp;=&nbsp;1,&nbsp;2,&nbsp;…,&nbsp;<var>n</var>,
    </div>
    где max берется по всем 
    <div class="formula">
        <var>m<sub>i</sub></var>&nbsp;=&nbsp;0,&nbsp;1,&nbsp;…,&nbsp;[<var>W</var>&#8260;<var>w<sub>i</sub></var>]
        и
        <var>x<sub>i</sub></var>&nbsp;=&nbsp;0,&nbsp;1,&nbsp;…,&nbsp;<var>W</var>,
    </div>
    где <var>f</var><sub><var>n</var>+1</sub>(<var>x</var><sub><var>n</var>+1</sub>)&nbsp;&#8801;&nbsp;0.
</li>
<li>
    Выразим <var>x</var><sub><var>i</var>+1</sub> как функцию
    <var>x<sub>i</sub></var> для гарантии того, что левая часть последнего
    уравнения является функцией лишь <var>x<sub>i</sub></var>. По определению
    <var>x</var><sub><var>i</var>+1</sub>&nbsp;&#8722;&nbsp;<var>x<sub>i</sub></var>
    представляет собой вес, загруженный на этапе <var>i</var>, т.&nbsp;е.
    <var>x</var><sub><var>i</var>+1</sub>&nbsp;&#8722;&nbsp;<var>x<sub>i</sub></var>&nbsp;=
    <var>w<sub>i</sub></var><var>m<sub>i</sub></var> или
    <var>x</var><sub><var>i</var>+1</sub>&nbsp;=
    <var>x<sub>i</sub></var>&nbsp;&#8722;&nbsp;<var>w<sub>i</sub></var><var>m<sub>i</sub></var>.
    Тогда рекуррентное уравнение приобретает следующий вид. 
    <div class="formula">
        <var>f<sub>i</sub></var>(<var>x<sub>i</sub></var>)&nbsp;=
        max&nbsp;{<var>r<sub>i</sub></var><var>m<sub>i</sub></var>&nbsp;+
        <var>f</var><sub><var>i</var>+1</sub>(<var>x<sub>i</sub></var>&#8722;<var>w<sub>i</sub></var><var>m<sub>i</sub></var>)},
        <var>i</var>&nbsp;=&nbsp;1,&nbsp;2,&nbsp;…,&nbsp;<var>n</var>,
    </div>
    где max берется по всем
    <div class="formula">
        <var>m<sub>i</sub></var>&nbsp;=&nbsp;0,&nbsp;1,&nbsp;…,&nbsp;[<var>W</var>&#8260;<var>w<sub>i</sub></var>]
        и
        <var>x<sub>i</sub></var>&nbsp;=&nbsp;0,&nbsp;1,&nbsp;…,&nbsp;<var>W</var>.
    </div>
</li>
</ol>
<p>
    Задача о загрузке является типичным представителем задачи распределения
    ресурсов, в которой ограниченный ресурс распределяется между конечным
    числом видов (экономической) деятельности. В таких моделях определения
    состояния на каждом этапе будет аналогично приведенному для задачи
    о загрузке : состоянием на этапе <var>i</var> является суммарное
    количество ресурса, распределяемого на этапах
    <var>i</var>,&nbsp;<var>i</var>+1,&nbsp;…,&nbsp;<var>n</var>.
</p>


<h2>Заключение</h2>

<p>
    Здесь были рассмотрены некоторые примеры детерминированных моделей
    динамического программирования. Принцип оптимальности является основой
    поэтапного решения задачи динамического программирования. Несмотря на то,
    что этот принцип не содержит информации о способах решения подзадач
    на каждом этапе, его применение существенно облегчает решение многих
    сложных задач, которые нельзя решить другими методами. Укажем два
    признака, характерных для задач, решаемых методами динамического
    программирования.
</p>
<ul>
<li>
    Задача <em>обладает свойством оптимальности для подзадач</em>, т.&nbsp;е.
    оптимальное решение задачи содержит оптимальные решения ее подзадач.
</li>
<li>
    Задача <em>имеет перекрывающиеся подзадачи</em>, т.&nbsp;е.
    при рекурсивном решении мы многократно выходим на одни и те же подзадачи.
</li>
</ul>


<h2>Литература</h2>

<ol>
<li>
    Кормен&nbsp;Т., Лейзерсон&nbsp;Ч., Ривест&nbsp;Р.
    <a href="http://rain.ifmo.ru/cat/view.php/books/cormen-1999">Алгоритмы: построение и анализ.</a>&nbsp;—
    М.: МЦНМО, 1999.
</li>
<li>
    Ахо&nbsp;А., Хопкрофт&nbsp;Д., Ульман&nbsp;Д.
    <a href="http://rain.ifmo.ru/cat/view.php/books/aho-2000">Структуры данных и алгоритмы.</a>&nbsp;—
    М.: Издательский дом «Вильямс», 2001.
</li>
<li>
    Таха&nbsp;Х.
    <a href="http://rain.ifmo.ru/cat/view.php/books/taha-2001">Введение в исследование операций.</a>&nbsp;—
    М.: Издательский дом «Вильямс», 2001.
</li>
<li>
    Беров&nbsp;В.И., Лапунов&nbsp;А.В., Матюхин&nbsp;В.А., Пономарев&nbsp;А.Е.
    Особенности национальных задач по информатике.&nbsp;—
    Киров: Триада-С, 2000.
</li>
</ol>

<p class="signature">Камышан Андрей</p>

<hr>
<div class="block">
<div class="block-head">
<b><a href="mailto:my-own-mail(at)mail(dot)ru">Маша</a></b>
/ 2009-05-27 21:27:59</div>
<p>Хочу сказать спасибо автору за такую статью.  Кучу сайтов, посвященных информатике, пересмотрела, но нигде такой доступной раскладки алгоритма LCS не встретила.  Да и к тому же везде статьи повторяются.  Еще раз огромное спасибо!!!!</p></div>
<div class="block">
<div class="block-head">
<b><a href="mailto:va(dot)ivashchenko(at)gmail(dot)com">Виталий</a></b>
/ 2010-07-08 12:21:22</div>
<p>Похоже, что в задаче о загрузке есть ошибка:</p>
<p>"... По определению x(i+1) &amp;#8722; x(i) представляет собой вес, загруженный на этапе i, т. е. x(i+1) &amp;#8722; x(i) = w(i)m(i) или x(i+1) = x(i) &amp;#8722; w(i)m(i). Тогда рекуррентное уравнение приобретает следующий вид.</p>
<p>fi(x(i)) = max {r(i)m(i) + f(i+1)(x(i)&amp;#8722;w(i)m(i))}, i = 1, 2, ?, n,..."</p>
<p>Если x(i+1) &amp;#8722; x(i) = w(i)m(i), то логично, чтобы x(i+1) = x(i) + w(i)m(i), а не x(i+1) = x(i) &amp;#8722; w(i)m(i).</p></div>
<div class="block">
<div class="block-head">
<b><a href="mailto:miwaqq@gmail.com">Миша</a></b>
/ 2011-11-14 00:35:37</div>
<p>Автору спасибо за статью. Маша, ты не читала Окулова? Это очень толковая книга и там про lcs хорошо написано</p></div>
<form action="http://rain.ifmo.ru/cat/comment.php/theory/algorithm-analysis/dynamic-programming-2004" method="post">
<table cellspacing="10">
<tbody><tr>
<td><b>Ваше имя</b></td>
<td><input type="text" name="name" size="40" maxlength="64" class="text"></td>
</tr>
<tr>
<td><b>Email</b></td>
<td><input type="text" name="email" size="40" maxlength="64" class="text"></td>
</tr>
<tr>
<td><b>Текущий день недели</b></td>
<td><input type="text" name="today" size="40" maxlength="64" class="text"> (строчными буквами)</td>
</tr>
<tr>
<td style="vertical-align:top"><b>Комментарий</b></td>
<td><textarea name="message" class="text" rows="10" cols="60"></textarea></td>
</tr>
<tr>
<td>&nbsp;</td>
<td><input type="submit" value="Отправить" class="button"></td>
</tr>
</tbody></table>
</form>

</td>
</tr>
</tbody></table>

<div id="foot">
Опубликовано 2004-06-24 23:52:51,
последнее обновление 2005-07-23 23:26:02
</div>



</body></html>